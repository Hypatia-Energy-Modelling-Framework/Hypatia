import pandas as pd
import numpy as np
import unittest
import copy
from hypatia.backend.ModelSettings import ModelSettings
from hypatia.backend.ModelData import ModelData
from hypatia.utility.constants import ModelMode
from hypatia.backend.Build import BuildModel
from hypatia.backend.tests.TestSettings import (
    SingleNodeOperationRampingTestSettings,
    SingleNodePlanningRampingTestSettings,
    MultiNodeOperationRampingTestSettings,
    MultiNodePlanningRampingTestSettings
)
import hypatia.error_log.Exceptions as hypatiaException

'''
Test how energy production can ramp up or down in each timestep according to the maximum and minimum ramping
capacity of each technology. This test is done by checking that:
    1. The model shfits production from one technology to the other in each time step as long as the increase 
       in production by each technology is not higher than what is specified in the max and min ramping parameters of that technology
We check this feature in the 4 main scenarios:
    1. Single region, planning
    2. Single region, operation
    3. Multi region, planning
    4. Multi region, operation
'''

class TestRampingSingleRegionOperation(unittest.TestCase):
    '''
    The scenario used in the test is:

        ------------------------------ Reg1 --------------------------------
        Elec_import   -> Elec |
                              |-> Elec Demand
        PV_park       -> Elec |
        
    '''

    def __init__(self, *args, **kwargs):
        super(TestRampingSingleRegionOperation, self).__init__(*args, **kwargs)

    # Checks if the model correctly tracks the emission generated by the model solution
    def test_max_production_ramping(self):
        
        # load the sets from TestSettings.py
        example_settings = SingleNodeOperationRampingTestSettings()
        settings = ModelSettings(
            ModelMode.Operation,
            example_settings.global_settings,
            example_settings.regional_settings,
        )

        
        # define the numerical parameters
        regional_parameters = settings.default_regional_parameters

        # Increment demand for elec to 1 for each timestamp
        regional_parameters["reg1"]["demand"] += 1

        # Increment the residual capacity for all techs
        regional_parameters["reg1"]["tech_residual_cap"].loc[:, (slice(None), ["Elec_import"])] += 200000000
        regional_parameters["reg1"]["tech_residual_cap"].loc[:, (slice(None), ["PV_park"])] += 1
        regional_parameters["reg1"]["annualprod_per_unitcapacity"].loc[:, (slice(None), ["PV_park"])] += 38373180


        n_techs = regional_parameters["reg1"]["demand"].shape[1]

        # iterate through the timesteps excluding the first one
        for row_index in range(1,regional_parameters["reg1"]["demand"].shape[0]):
            sub_dataset = regional_parameters["reg1"]["demand"].iloc[row_index,:]
            sub_dataset = pd.DataFrame(np.array(sub_dataset).reshape(1,n_techs))
            sub_dataset += row_index
            regional_parameters["reg1"]["demand"].iloc[row_index,:] = sub_dataset  

        # Increment the cost for Heat_import and Elec_import so it is better to fulfil the demand using NG
        regional_parameters["reg1"]["tech_var_cost"].loc[:, (slice(None), ["Elec_import"])] += 10

        # Increment the Emission production for the NG transformation technologies
        regional_parameters["reg1"]["prod_max_ramp"].loc[:,(slice(None), ["PV_park"])] -= 0.5
        
        model_data = ModelData(
            settings,
            settings.default_global_parameters,
            settings.default_trade_parameters,
            regional_parameters
        )
        
        model = BuildModel(model_data=model_data)
        results = model._solve(verbosity=False, solver="GUROBI")
        
        # Check that we used PV_park to produced elec 
        supply_technology_use = pd.DataFrame(
            data=results.technology_prod["reg1"]["Supply"].value,
            index=pd.MultiIndex.from_product(
                [settings.years, settings.time_steps],
                names=["Years", "Timesteps"],
            ),
            columns=settings.technologies["reg1"]["Supply"],
        )
        
        self.assertEqual(np.sum(supply_technology_use["PV_park"].values), [19190970])
        
        expected = np.arange(1,4381,0.5)            
        self.assertTrue(np.array_equal(expected,np.around(supply_technology_use["PV_park"].values, decimals=10)))

    def test_min_production_ramping(self):
        
        # load the sets from TestSettings.py
        example_settings = SingleNodeOperationRampingTestSettings()
        settings = ModelSettings(
            ModelMode.Operation,
            example_settings.global_settings,
            example_settings.regional_settings,
        )

        
        # define the numerical parameters
        regional_parameters = settings.default_regional_parameters

        # Increment demand for elec to 1 for each timestamp
        regional_parameters["reg1"]["demand"] += 8760

        # Increment the residual capacity for all techs
        regional_parameters["reg1"]["tech_residual_cap"].loc[:, (slice(None), ["Elec_import"])] += 200000000
        regional_parameters["reg1"]["tech_residual_cap"].loc[:, (slice(None), ["PV_park"])] += 1
        regional_parameters["reg1"]["annualprod_per_unitcapacity"].loc[:, (slice(None), ["PV_park"])] += 38373180


        n_techs = regional_parameters["reg1"]["demand"].shape[1]

        # iterate through the timesteps excluding the first one
        for row_index in range(1,regional_parameters["reg1"]["demand"].shape[0]):
            sub_dataset = regional_parameters["reg1"]["demand"].iloc[row_index,:]
            sub_dataset = pd.DataFrame(np.array(sub_dataset).reshape(1,n_techs))
            sub_dataset -= row_index
            regional_parameters["reg1"]["demand"].iloc[row_index,:] = sub_dataset  

        # Increment the cost for Heat_import and Elec_import so it is better to fulfil the demand using NG
        regional_parameters["reg1"]["tech_var_cost"].loc[:, (slice(None), ["Elec_import"])] += 10

        # Increment the Emission production for the NG transformation technologies
        regional_parameters["reg1"]["prod_min_ramp"].loc[:,(slice(None), ["PV_park"])] -= 0.5

        model_data = ModelData(
            settings,
            settings.default_global_parameters,
            settings.default_trade_parameters,
            regional_parameters
        )
        model = BuildModel(model_data=model_data)
        results = model._solve(verbosity=False, solver="GUROBI")

        # Check that we used PV_park to produced elec 
        supply_technology_use = pd.DataFrame(
            data=results.technology_prod["reg1"]["Supply"].value,
            index=pd.MultiIndex.from_product(
                [settings.years, settings.time_steps],
                names=["Years", "Timesteps"],
            ),
            columns=settings.technologies["reg1"]["Supply"],
        )

        
        self.assertEqual(np.sum(supply_technology_use["PV_park"].values), [19190970])
        
        expected = np.arange(1,4381,0.5)
        expected_reverse = np.flipud(expected)
        self.assertTrue(np.array_equal(expected_reverse,np.around(supply_technology_use["PV_park"].values, decimals=10)))

class TestRampingSingleRegionPlanning(unittest.TestCase):
    '''
    The scenario used in the test is:

        ------------------------------ Reg1 --------------------------------
        Elec_import   -> Elec |
                              |-> Elec Demand
        PV_park       -> Elec |
        
    '''

    def __init__(self, *args, **kwargs):
        super(TestRampingSingleRegionPlanning, self).__init__(*args, **kwargs)

    # Checks if the model correctly tracks the emission generated by the model solution
    def test_max_production_ramping(self):
        
        # load the sets from TestSettings.py
        example_settings = SingleNodePlanningRampingTestSettings()
        settings = ModelSettings(
            ModelMode.Planning,
            example_settings.global_settings,
            example_settings.regional_settings,
        )


        # define the numerical parameters
        regional_parameters = settings.default_regional_parameters

        # Increment demand for elec to 1 for each timestamp
        regional_parameters["reg1"]["demand"] += 1

        regional_parameters["reg1"]["tech_inv"].loc[:, (slice(None), ["PV_park"])] += 1000000
        regional_parameters["reg1"]["tech_inv"].loc[:, (slice(None), ["Elec_import"])] += 100000
        regional_parameters["reg1"]["tech_maxtotcap"].loc[:, (slice(None), ["PV_park"])] += 1
        regional_parameters["reg1"]["annualprod_per_unitcapacity"].loc[:, (slice(None), ["PV_park"])] += 38373180

        n_techs = regional_parameters["reg1"]["demand"].shape[1]

        # iterate through the timesteps excluding the first one
        for row_index in range(1,regional_parameters["reg1"]["demand"].shape[0]):
            sub_dataset = regional_parameters["reg1"]["demand"].iloc[row_index,:]
            sub_dataset = pd.DataFrame(np.array(sub_dataset).reshape(1,n_techs))
            sub_dataset += row_index
            regional_parameters["reg1"]["demand"].iloc[row_index,:] = sub_dataset  

        # Increment the cost for Heat_import and Elec_import so it is better to fulfil the demand using NG
        regional_parameters["reg1"]["tech_var_cost"].loc[:, (slice(None), ["Elec_import"])] += 1000000000

        # Increment the Emission production for the NG transformation technologies
        regional_parameters["reg1"]["prod_max_ramp"].loc[:,(slice(None), ["PV_park"])] -= 0.5

        model_data = ModelData(
            settings,
            settings.default_global_parameters,
            settings.default_trade_parameters,
            regional_parameters
        )

        model = BuildModel(model_data=model_data)
        results = model._solve(verbosity=False, solver="GUROBI")

        # Check that we used PV_park to produced elec 
        supply_technology_use = pd.DataFrame(
            data=results.technology_prod["reg1"]["Supply"].value,
            index=pd.MultiIndex.from_product(
                [settings.years, settings.time_steps],
                names=["Years", "Timesteps"],
            ),
            columns=settings.technologies["reg1"]["Supply"],
        )
        
        self.assertEqual(np.sum(supply_technology_use["PV_park"].values), [345332340])
        
        expected = np.arange(1,26281,1)            
        self.assertTrue(np.array_equal(expected,np.around(supply_technology_use["PV_park"].values, decimals=10)))

    def test_min_production_ramping(self):
        
        # load the sets from TestSettings.py
        example_settings = SingleNodePlanningRampingTestSettings()
        settings = ModelSettings(
            ModelMode.Planning,
            example_settings.global_settings,
            example_settings.regional_settings,
        )


        # define the numerical parameters
        regional_parameters = settings.default_regional_parameters

        # Increment demand for elec to 1 for each timestamp
        regional_parameters["reg1"]["demand"] += 26280

        regional_parameters["reg1"]["tech_inv"].loc[:, (slice(None), ["PV_park"])] += 1000000
        regional_parameters["reg1"]["tech_inv"].loc[:, (slice(None), ["Elec_import"])] += 100000
        regional_parameters["reg1"]["tech_maxtotcap"].loc[:, (slice(None), ["PV_park"])] += 1
        regional_parameters["reg1"]["annualprod_per_unitcapacity"].loc[:, (slice(None), ["PV_park"])] += 38373180

        n_techs = regional_parameters["reg1"]["demand"].shape[1]

        # iterate through the timesteps excluding the first one
        for row_index in range(1,regional_parameters["reg1"]["demand"].shape[0]):
            sub_dataset = regional_parameters["reg1"]["demand"].iloc[row_index,:]
            sub_dataset = pd.DataFrame(np.array(sub_dataset).reshape(1,n_techs))
            sub_dataset -= row_index
            regional_parameters["reg1"]["demand"].iloc[row_index,:] = sub_dataset  

        # Increment the cost for Heat_import and Elec_import so it is better to fulfil the demand using NG
        regional_parameters["reg1"]["tech_var_cost"].loc[:, (slice(None), ["Elec_import"])] += 1000000000

        # Increment the Emission production for the NG transformation technologies
        regional_parameters["reg1"]["prod_max_ramp"].loc[:,(slice(None), ["PV_park"])] -= 0.5

        model_data = ModelData(
            settings,
            settings.default_global_parameters,
            settings.default_trade_parameters,
            regional_parameters
        )

        model = BuildModel(model_data=model_data)
        results = model._solve(verbosity=False, solver="GUROBI")

        # Check that we used PV_park to produced elec 
        supply_technology_use = pd.DataFrame(
            data=results.technology_prod["reg1"]["Supply"].value,
            index=pd.MultiIndex.from_product(
                [settings.years, settings.time_steps],
                names=["Years", "Timesteps"],
            ),
            columns=settings.technologies["reg1"]["Supply"],
        )

        
        self.assertEqual(np.sum(supply_technology_use["PV_park"].values), [345332340])
        
        expected = np.arange(1,26281,1)
        expected_reverse = np.flipud(expected)
        self.assertTrue(np.array_equal(expected_reverse,np.around(supply_technology_use["PV_park"].values, decimals=10)))

class TestRampingMultiRegionOperation(unittest.TestCase):
    '''
    The scenario used in the test is:

        ------------ Reg1 ----------       ----------------- Reg2 ----------------
                                            Elec_import ----> Elec |
                                                                  |-> Elec Demand
        PV_park -------------------------------------------> Elec |
        
    '''

    def __init__(self, *args, **kwargs):
        super(TestRampingMultiRegionOperation, self).__init__(*args, **kwargs)
        
    # Checks if the model correctly tracks the emission generated by the model solution
    def test_max_production_ramping(self):
        
        #load the sets from TestSettings.py
        example_settings = MultiNodeOperationRampingTestSettings()
        settings = ModelSettings(
            ModelMode.Operation,
            example_settings.global_settings,
            example_settings.regional_settings,
        )


        # define the numerical parameters
        regional_parameters = settings.default_regional_parameters
        trade_parameters = settings.default_trade_parameters

        # Increment demand for elec to 1 for each timestamp
        regional_parameters["reg2"]["demand"] += 1

        # Increment the residual capacity for all techs
        regional_parameters["reg1"]["tech_residual_cap"].loc[:, (slice(None), ["Elec_import"])] += 200000000
        regional_parameters["reg2"]["tech_residual_cap"].loc[:, (slice(None), ["Elec_import"])] += 200000000
        regional_parameters["reg1"]["tech_residual_cap"].loc[:, (slice(None), ["PV_park"])] += 1
        regional_parameters["reg1"]["annualprod_per_unitcapacity"].loc[:, (slice(None), ["PV_park"])] += 38373180

        trade_parameters["line_residual_cap"].loc[:, (slice(None), ["Elec"])] = 200000000

        n_techs = regional_parameters["reg1"]["demand"].shape[1]

        for row_index in range(1,regional_parameters["reg2"]["demand"].shape[0]):
            sub_dataset = regional_parameters["reg2"]["demand"].iloc[row_index,:]
            sub_dataset = pd.DataFrame(np.array(sub_dataset).reshape(1,n_techs))
            sub_dataset += row_index
            regional_parameters["reg2"]["demand"].iloc[row_index,:] = sub_dataset 

        # Increment the cost for Heat_import and Elec_import so it is better to fulfil the demand using NG
        regional_parameters["reg1"]["tech_var_cost"].loc[:, (slice(None), ["Elec_import"])] += 1000
        regional_parameters["reg2"]["tech_var_cost"].loc[:, (slice(None), ["Elec_import"])] += 10

        # Increment the Emission production for the NG transformation technologies
        regional_parameters["reg1"]["prod_max_ramp"].loc[:,(slice(None), ["PV_park"])] -= 0.5

        model_data = ModelData(
            settings,
            settings.default_global_parameters,
            trade_parameters,
            regional_parameters
        )
        model = BuildModel(model_data=model_data)
        results = model._solve(verbosity=False, solver="GUROBI")

        # Check that we used PV_park to produced elec 
        supply_technology_use_reg1 = pd.DataFrame(
            data=results.technology_prod["reg1"]["Supply"].value,
            index=pd.MultiIndex.from_product(
                [settings.years, settings.time_steps],
                names=["Years", "Timesteps"],
            ),
            columns=settings.technologies["reg1"]["Supply"],
        )

        supply_technology_use_reg2 = pd.DataFrame(
            data=results.technology_prod["reg2"]["Supply"].value,
            index=pd.MultiIndex.from_product(
                [settings.years, settings.time_steps],
                names=["Years", "Timesteps"],
            ),
            columns=settings.technologies["reg2"]["Supply"],
        )
        

        self.assertEqual(np.sum(supply_technology_use_reg1["PV_park"].values), [19190970])
        
        expected = np.arange(1,4381,0.5)
        self.assertTrue(np.array_equal(expected,np.around(supply_technology_use_reg1["PV_park"].values, decimals=10)))

        self.assertEqual(np.sum(supply_technology_use_reg2["Elec_import"].values), [19182210])
        
        expected = np.arange(0,4380,0.5)
        self.assertTrue(np.array_equal(expected,np.around(supply_technology_use_reg2["Elec_import"].values, decimals=10)))
        
    def test_min_production_ramping(self):
        
        #load the sets from TestSettings.py
        example_settings = MultiNodeOperationRampingTestSettings()
        settings = ModelSettings(
            ModelMode.Operation,
            example_settings.global_settings,
            example_settings.regional_settings,
        )


        # define the numerical parameters
        regional_parameters = settings.default_regional_parameters
        trade_parameters = settings.default_trade_parameters

        # Increment demand for elec to 1 for each timestamp
        regional_parameters["reg2"]["demand"] += 8760

        # Increment the residual capacity for all techs
        regional_parameters["reg2"]["tech_residual_cap"].loc[:, (slice(None), ["Elec_import"])] += 200000000
        regional_parameters["reg1"]["tech_residual_cap"].loc[:, (slice(None), ["PV_park"])] += 1
        regional_parameters["reg1"]["annualprod_per_unitcapacity"].loc[:, (slice(None), ["PV_park"])] += 38373180 

        n_techs = regional_parameters["reg2"]["demand"].shape[1]

        # iterate through the timesteps excluding the first one
        for row_index in range(1,regional_parameters["reg2"]["demand"].shape[0]):
            sub_dataset = regional_parameters["reg2"]["demand"].iloc[row_index,:]
            sub_dataset = pd.DataFrame(np.array(sub_dataset).reshape(1,n_techs))
            sub_dataset -= row_index
            regional_parameters["reg2"]["demand"].iloc[row_index,:] = sub_dataset  

        # Increment the cost for Heat_import and Elec_import so it is better to fulfil the demand using NG
        regional_parameters["reg1"]["tech_var_cost"].loc[:, (slice(None), ["Elec_import"])] += 10000
        regional_parameters["reg2"]["tech_var_cost"].loc[:, (slice(None), ["Elec_import"])] += 1000

        regional_parameters["reg1"]["prod_min_ramp"].loc[:,(slice(None), ["PV_park"])] -= 0.5
        trade_parameters["line_residual_cap"].loc[:, (slice(None), ["Elec"])] = 200000000

        model_data = ModelData(
            settings,
            settings.default_global_parameters,
            trade_parameters,
            regional_parameters
        )

        model = BuildModel(model_data=model_data)
        results = model._solve(verbosity=False, solver="GUROBI")

        # Check that we used PV_park to produced elec 
        supply_technology_use_reg1 = pd.DataFrame(
            data=results.technology_prod["reg1"]["Supply"].value,
            index=pd.MultiIndex.from_product(
                [settings.years, settings.time_steps],
                names=["Years", "Timesteps"],
            ),
            columns=settings.technologies["reg1"]["Supply"],
        )

        supply_technology_use_reg2 = pd.DataFrame(
            data=results.technology_prod["reg2"]["Supply"].value,
            index=pd.MultiIndex.from_product(
                [settings.years, settings.time_steps],
                names=["Years", "Timesteps"],
            ),
            columns=settings.technologies["reg2"]["Supply"],
        )
        

        self.assertEqual(np.sum(supply_technology_use_reg1["PV_park"].values), [19190970])
        
        expected = np.arange(1,4381,0.5)
        expected_reverse= np.flipud(expected)
        self.assertTrue(np.array_equal(expected_reverse,np.around(supply_technology_use_reg1["PV_park"].values, decimals=10)))

        self.assertEqual(np.sum(supply_technology_use_reg2["Elec_import"].values), [19182210])
        
        expected = np.arange(0,4380,0.5)
        expected_reverse= np.flipud(expected)
        self.assertTrue(np.array_equal(expected_reverse,np.around(supply_technology_use_reg2["Elec_import"].values, decimals=10)))